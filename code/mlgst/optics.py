import numpy as np


def beam_splitter(mode1: int, mode2: int, modes: int) -> np.ndarray:
    mat = np.identity(modes, dtype=np.complex128)
    mat[mode1, mode1] = mat[mode2, mode2] = 1.0 / np.sqrt(2)
    mat[mode1, mode2] = mat[mode2, mode1] = 1.0j / np.sqrt(2)
    return mat


def beam_splitter_inv(mode1: int, mode2: int, modes: int) -> np.ndarray:
    mat = np.identity(modes, dtype=np.complex128)
    mat[mode1, mode1] = mat[mode2, mode2] = 1.0j / np.sqrt(2)
    mat[mode1, mode2] = mat[mode2, mode1] = 1.0 / np.sqrt(2)
    return mat


def phase_shifter(mode: int, modes: int, angle: float) -> np.ndarray:
    mat = np.identity(modes, dtype=np.complex128)
    mat[mode, mode] = np.exp(1j * angle)
    return mat


def swap(mode1: int, mode2: int, modes: int) -> np.ndarray:
    mat = np.identity(modes, dtype=np.complex128)
    mat[:, [mode1, mode2]] = mat[:, [mode2, mode1]]
    return mat


def mach_zehnder(mode_con: int, mode_sen: int, modes: int, angle: float) -> np.ndarray:
    bs = beam_splitter_inv(mode_con, mode_sen, modes)
    phase = phase_shifter(mode_con, modes, angle)
    return bs @ phase @ bs


def get_unitary(powers: np.ndarray, c_mat: np.ndarray, phi0: np.ndarray) -> np.ndarray:
    """Get the unitary operator corresponding to the circuit generated by `c_mat` and `phi0`."""
    phi = (c_mat @ powers) + phi0

    bs = beam_splitter_inv(0, 1, 2)
    unitary = np.identity(2)
    for i in range(powers.shape[0]):
        unitary = phase_shifter(1, 2, phi[i]) @ bs @ unitary
    unitary = bs @ unitary

    return unitary
